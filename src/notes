-------------------------------------------GETTING REACT AND REDUX TOGETHER------------------------------------------------

Setting up the initial component:
- So we need to have an component that uses state and props, we will be using a class component.
- when implementing the constructor for a react.component subclass, you should call super(props) before any other statement
otherwise, this.props will be undefined in the constructor.
- the constructor is only used for two purposes, initializing local state by assigning an object to this.state
 and binding event handler methods to an instance.


 IMPLEMENTING REACT AND REDUX
 - so first I will create an action creator and I need to start thinking about how the state should look.
 - I will also need some types. So I don't want the api browser to happen on the page load, I want it to happen
 when the a user clicks ok. so when The desired button gets clicked I want an async action to be fired off. So i will
 eventually want three action creators that will each handle the state for the Browser api, google api and
 twitter api.
 - so now we are creating the actions, first we will just set up a synchronous request to be sent off with a button, then
 we will create an async one.
 - actions do need a type
 - the design of an action is up to us but in this aplication we will be using the flux standard approach
 - we will be creating an action creator that returns an object
 - action creators are literaly just functions that create actions.
 - normally you will have to dispatch the action returned by the creator but will will be doing that with connect from
 React Redux.

 - now we are on to reducers, we have created the action creators.
 - The Reducers specify how the state changes
 - now we have a rough idea about what the initial state will look like
 - ok so now we have made the combineReducer file in order to combine our reducers when we create more. this combined
 reducer will be passed to the store.


 - now we are on to creating the store

 STORE:
 - the store is the object that brings the object and the reducer together. the actions being a description of what happened
 and the reducers that actually change the state.
 - we will only have a single store in a Redux application. Now we will create our store

 - so initially combineReducers combines everything under one object but when we split The reducers and each reducer
 handles its specific part of the state. SO I think that how I have my reducers returning the state is correct. it just
 looks weird initially with the because of what the combineReducer does with it combinding everything into a single object
 -  the combine reducer creates an object where all the keys are the reducers

 DATA FLOW:
 - it is a unidirectional data flow. This means that data in an application follows the same lifecycle pattern. making it
easier to predict.
- the lifecycle goes like this
1) an action gets dispatched
2) The Redux store calls the reducer function you gave it
3) The root reducer may combine the output of multiple reducers into a single state tree
4) The Redux store saves the complete state tree returned by the root reducer


REACT REDUX :

- the provider <Provider />, which makes the Redux store available to the rest of your app
- then there is the connect store, which is a little more complicated. in our application, I definetly want to make
our browser component connected to the store

MAPSTATETOPROPS:
-mapStateToProps is used for selecting the part of the data form the store that the connected needs. it gets called
every time the store state changes
- it receives the entire store state and should return an object of data this component needs
- the first argument to mapStateToProps function is the entire Redux store state
- ownProps may be used if your component needs the data from its own props to retrieve data from the store. This argument
will contain all of the props given to the wrapper component that was generated by connect
- map state to props should only return an plain object that has all the info it needs.
- each field in the object will become a prop for your actual component
-The values in the fields will be ised to determine if your component needs to re-render

- I think for our browser component we wont be using mapStateToProps for the connect function. I will use that in another
component that is specifically used for the UI experience, then I can reuse that component for the other API

MAPDISPATCHTOPROPS:
-dispatching an action is the only way to trigger a state change.
-mapDispatchToProps is used for dispatching actions to the store.
- we will be using the object shorthand form of mapDispatchToProps, which is more declarative and easier to use
- so you just import the action creators and then use them as values in mapDispatchToProps object 
