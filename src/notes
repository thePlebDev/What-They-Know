-------------------------------------------GETTING REACT AND REDUX TOGETHER------------------------------------------------

Setting up the initial component:
- So we need to have an component that uses state and props, we will be using a class component.
- when implementing the constructor for a react.component subclass, you should call super(props) before any other statement
otherwise, this.props will be undefined in the constructor.
- the constructor is only used for two purposes, initializing local state by assigning an object to this.state
 and binding event handler methods to an instance.


 IMPLEMENTING REACT AND REDUX
 - so first I will create an action creator and I need to start thinking about how the state should look.
 - I will also need some types. So I don't want the api browser to happen on the page load, I want it to happen
 when the a user clicks ok. so when The desired button gets clicked I want an async action to be fired off. So i will
 eventually want three action creators that will each handle the state for the Browser api, google api and
 twitter api.
 - so now we are creating the actions, first we will just set up a synchronous request to be sent off with a button, then
 we will create an async one.
 - actions do need a type
 - the design of an action is up to us but in this aplication we will be using the flux standard approach
 - we will be creating an action creator that returns an object
 - action creators are literaly just functions that create actions.
 - normally you will have to dispatch the action returned by the creator but will will be doing that with connect from
 React Redux.

 - now we are on to reducers, we have created the action creators.
 - The Reducers specify how the state changes
 - now we have a rough idea about what the initial state will look like
 - ok so now we have made the combineReducer file in order to combine our reducers when we create more. this combined
 reducer will be passed to the store.


 - now we are on to creating the store

 STORE:
 - the store is the object that brings the object and the reducer together. the actions being a description of what happened
 and the reducers that actually change the state.
 - we will only have a single store in a Redux application. Now we will create our store

 - so initially combineReducers combines everything under one object but when we split The reducers and each reducer
 handles its specific part of the state. SO I think that how I have my reducers returning the state is correct. it just
 looks weird initially with the because of what the combineReducer does with it combinding everything into a single object
 -  the combine reducer creates an object where all the keys are the reducers

 DATA FLOW:
 - it is a unidirectional data flow. This means that data in an application follows the same lifecycle pattern. making it
easier to predict.
- the lifecycle goes like this
1) an action gets dispatched
2) The Redux store calls the reducer function you gave it
3) The root reducer may combine the output of multiple reducers into a single state tree
4) The Redux store saves the complete state tree returned by the root reducer


REACT REDUX :

- the provider <Provider />, which makes the Redux store available to the rest of your app
- then there is the connect store, which is a little more complicated. in our application, I definetly want to make
our browser component connected to the store

MAPSTATETOPROPS:
-mapStateToProps is used for selecting the part of the data form the store that the connected needs. it gets called
every time the store state changes
- it receives the entire store state and should return an object of data this component needs
- the first argument to mapStateToProps function is the entire Redux store state
- ownProps may be used if your component needs the data from its own props to retrieve data from the store. This argument
will contain all of the props given to the wrapper component that was generated by connect
- map state to props should only return an plain object that has all the info it needs.
- each field in the object will become a prop for your actual component
-The values in the fields will be ised to determine if your component needs to re-render

- I think for our browser component we wont be using mapStateToProps for the connect function. I will use that in another
component that is specifically used for the UI experience, then I can reuse that component for the other API

MAPDISPATCHTOPROPS:
-dispatching an action is the only way to trigger a state change.
-mapDispatchToProps is used for dispatching actions to the store.
- we will be using the object shorthand form of mapDispatchToProps, which is more declarative and easier to use
- so you just import the action creators and then use them as values in mapDispatchToProps object
- so apparently my constructor is useless and I am not sure why. looks like I am going to look into that.

class components:
- so we definitely need the constructor if we need to use  a lifecycle method.
- we will be using componentDidMount because of the fact that I want the browser data to load before and have it saved into
the session state where it can be accessed but it would be nice if I could have it appear in the state once it is loaded
- but I want a button to be clicked and the data to be displayed. I am not sure on how I want to do that yet

componentDidMount:
- this is invoked immediately after a component is mounted. this is where we will make the api calls for the browser.
the others I am going to make an asyncronous action to do that.

Why do we need to bind our functions?
- the reason that we have to do this is because of how 'this' works in javascript, the dynamically scoped nature of
'this' in javascript. So I need a better understanding of how 'this' works then.

'THIS':
- in JavaScript there are two ways to invoke a function.

1)the do method object.method()
- this means that we are invoking the method that is on the object. we look to left of the dot to find the context of 'this'
in this case 'this' would be in the context for the object

2) call and apparently
- instead of using the dot rule, we are just straight up saying what we want 'this' to refer to.

- it is important to be clear about how functions can be invoked in javascript because 'this' is dynamically scoped. it means
that the value of 'this' is tied to how a fucntion is called
-now I will get a better look on what happens to a function internally when it gets invoked(the execution context )


what happens internally when a function is invoked(execution context):
-there are three types of execution context
1) global: is the default. the value of this will be equal to the global object.

2) functional execution: every time a function is invoked, a brand new execution context is created for that function

THE EXECUTION STACK:
- also know as the call stack(Last in first out)
- when the Javascript engine first encounters my script it creates a gloabl execution context and pushes it to the
current execution stack. same goes for when the engine finds a function but it creates a new execution context for
that function and pushes it to the top of the stack
- when the function gets executed, it gets popped off from the stack

how the execution context is created:
1)creation phase: the execution context is created during the creation phase. Following things happen during the
creation phase. The lexical environment component is created. the lexical environment is the creation of all the
references to the objects
- when you see 'this' used in a function, you must see how that function is called because the way that the
function is called will change the value of 'this'.

2)execution phase: in this phase all the assignments are done and the code is finally executed
- so that was a whole lot, to basically tell me that a new execution context happens when a function is encountered


- my problems are still coming from a lack of understanding of what 'this' means in the context of the application
- so I will now read up on what the value of 'this' is

WTF IS THIS:
- the value of this will always be determined by the execution context
- in a normal function call 'this' refers to the global context

- the bind method, using the bind method creates a new function with the same body and scope as the original but
'this' now is bound to the first argument in the bind method.
- the onClick which is basically like using onclick in HTML or adding an event listener in HTML, attaches a function
to a click event
- however, for any event listener the target element(e.currentTerget)  is what 'this' refers to. We can think of event
listeners as passing in the target element into 'call' as the first element
- so this should refer to the target element

- in my application this refers to the whole class and everything inside of it. so we are able to get at the method
that we want to call but the problem lies in the execution of the method. We need to understand the execution context
of our function in order to get to the bottom of 'this'.

- so since we use onClick the initial value of 'this' is the element that our onClick is on
- we use bind to basically override what the old this value was
- so we know that the 'this' is not of the global context
- so I think that the execution context of our component is the actual object its self
- our current problem is that the value of 'this' is undefined.
- so the problem seems to be something to do with the contexts. With creating a new context that is different than
the original
- so now I have to see what context 'this' is referring to. I think it is refering to global scope.
-so the default binding is global scope
- when you call an method on an object like this obj.method() the 'this' value refers to the object. This is what is
called implicit binding. I need to read what onClick does in terms of binding.
- in our application when we call this.actionCreator, it falls back to the default binding. This has to be because of the
fact that we are not providing execution context for the method that is actionCreator. So 'this' points to the global
object.

SUMMARY OF WHAT HAPPENS TO 'THIS':
-the event handler method loses its implicitly bound context
implicit binding: states that when you are calling a function, look to the left of the dot and that is what the this
keyword will reference
- the 'this' value will then fall back to default binding.
- to solve this problem we can bind the function or we can just use an arrow function because it does not have its own this
value and will use the lexical 'this' binding.

- so I think I have a basic understanding of what is happening, basically, in short it loses its binding because the function
does not share the same execution context as the outer object. That is why we have to bind it. if the function is not called
with an object reference, apply, call or bind, then the value of 'this' is set to default binding which is global

- Now I just have to bind the function in the constructor to make the value of 'this' work. It is now bound and will
reference the component thanks to the bind method.

- so I have put in a mapStateToProps just so I can console.log out the state. mapStateToProps runs everytime the state
changes, so if the state changes, then I will be able to see it.

- right now I am having a problem with what the state is displaying. I want to make three reducers and I want them all to
handle there own state. So i need to read up more on what is happening to the state and the reducers and all that redux
stuff. FML, I guess just keep trucking along
